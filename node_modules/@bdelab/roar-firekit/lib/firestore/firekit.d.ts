import { UserData, RoarUser } from './user';
import { TaskVariantInput, RoarTaskVariant } from './task';
import { RoarRun } from './run';
import { DocumentReference } from 'firebase/firestore';
export interface ConfigData {
    firebaseConfig: {
        apiKey: string;
        authDomain: string;
        projectId: string;
        storageBucket: string;
        messagingSenderId: string;
        appId: string;
        measurementId: string;
    };
    rootDoc: string[];
}
/**
 * The RoarFirekit class is the main entry point for the ROAR Firestore API.
 * It represents multiple linked Firestore documents and provides methods
 * for interacting with them.
 */
export declare class RoarFirekit {
    userInfo: UserData;
    taskInfo: TaskVariantInput;
    user: RoarUser | undefined;
    task: RoarTaskVariant | undefined;
    run: RoarRun | undefined;
    rootDoc: DocumentReference;
    /**
     * Create a RoarFirekit. This expects an object with keys `userInfo`,
     * `taskInfo`, and `confg` where `userInfo` is a [[UserData]] object,
     * `taskInfo` is a [[TaskVariantInput]] object and `config` is a
     * [[ConfigData]] object.
     * @param {{userInfo: UserData, taskInfo: TaskVariantInput, config: ConfigData}=} destructuredParam
     *     userInfo: The user input object
     *     taskInfo: The task input object
     *     config: Firebase configuration object
     */
    constructor({ userInfo, taskInfo, config }: {
        userInfo: UserData;
        taskInfo: TaskVariantInput;
        config: ConfigData;
    });
    /**
     * Start the ROAR run. Push the task, user, and run info to Firestore
     * Call this method before starting the jsPsych experiment.
     * @method
     * @async
     */
    startRun(): Promise<void>;
    /**
     * Finish the ROAR run by marking it as finished in Firestore.
     * Call this method after the jsPsych experiment finishes. For example:
     *
     * ```javascript
     * jsPsych.init({
     *   timeline: exp,
     *   on_finish: function(data) {
     *     firekit.finishRun();
     *   }
     * });
     * ```
     * @method
     * @async
     */
    finishRun(): Promise<import("@firebase/auth").Auth>;
    /**
     * Add new trial data to this run on Firestore.
     *
     * This method can be added to individual jsPsych trials by calling it from
     * the `on_finish` function, like so:
     *
     * ```javascript
     * var trial = {
     *   type: 'image-keyboard-response',
     *   stimulus: 'imgA.png',
     *   on_finish: function(data) {
     *     firekit.addTrialData(data);
     *   }
     * };
     * ```
     *
     * Or you can call it from all trials in a jsPsych
     * timeline by calling it from the `on_data_update` callback. In the latter
     * case, you can avoid saving extraneous trials by conditionally calling
     * this method based on the data. For example:
     *
     * ```javascript
     * const timeline = [
     *   // A fixation trial; don't save to Firestore
     *   {
     *     type: htmlKeyboardResponse,
     *     stimulus: '<div style="font-size:60px;">+</div>',
     *     choices: "NO_KEYS",
     *     trial_duration: 500,
     *   },
     *   // A stimulus and response trial; save to Firestore
     *   {
     *     type: imageKeyboardResponse,
     *     stimulus: 'imgA.png',
     *     data: { saveToFirestore: true },
     *   }
     * ]
     * jsPsych.init({
     *   timeline: timeline,
     *   on_data_update: function(data) {
     *     if (data.saveToFirestore) {
     *       firekit.addTrialData(data);
     *     }
     *   }
     * });
     * ```
     *
     * @method
     * @async
     * @param {*} trialData - An object containing trial data.
     */
    writeTrial(trialData: Record<string, unknown>): Promise<void>;
}
